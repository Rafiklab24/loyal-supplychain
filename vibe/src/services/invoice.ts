/**
 * Invoice Generation Service
 * Generates invoices from shipment data and supports persistence
 */

import { apiClient } from './api';
import { accountingService } from './accounting';
import type { 
  Invoice, 
  InvoiceType, 
  InvoiceLanguage, 
  InvoiceGenerationOptions,
  InvoiceItem,
  PartyInfo,
} from '../types/invoice';
import { LOYAL_COMPANY_INFO, LOYAL_BANK_DETAILS } from '../types/invoice';
import type { Shipment } from '../types/api';

// Re-export defaults
export { LOYAL_COMPANY_INFO, LOYAL_BANK_DETAILS };

class InvoiceService {
  /**
   * Generate a unique invoice number (for preview only)
   * Real invoice numbers are generated by the database sequence
   */
  generatePreviewInvoiceNumber(type: InvoiceType): string {
    const prefix = type === 'purchase' ? 'PI' : 'SI'; // Purchase Invoice / Sales Invoice
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = String(date.getMonth() + 1).padStart(2, '0');
    return `${prefix}-PREVIEW-${year}${month}`;
  }

  /**
   * Fetch shipment data by ID
   */
  async getShipmentData(shipmentId: string): Promise<Shipment | null> {
    try {
      const response = await apiClient.get(`/shipments/${shipmentId}`);
      return response.data;
    } catch (error) {
      console.error('[Invoice] Failed to fetch shipment:', error);
      return null;
    }
  }

  /**
   * Generate invoice from shipment data (preview only, not saved)
   */
  async generateFromShipment(options: InvoiceGenerationOptions): Promise<Invoice | null> {
    const { shipment_id, type, language, include_bank_details = true, custom_notes, custom_payment_terms } = options;

    // Fetch shipment data
    const shipment = await this.getShipmentData(shipment_id);
    if (!shipment) {
      console.error('[Invoice] Shipment not found');
      return null;
    }

    // Determine seller and buyer based on invoice type
    // Purchase Invoice: We (Loyal) are buying, supplier is seller
    // Sales Invoice: We (Loyal) are selling, customer is buyer
    const isPurchase = type === 'purchase';

    const seller: PartyInfo = isPurchase 
      ? this.extractSupplierInfo(shipment)
      : this.getLoyalAsParty();

    const buyer: PartyInfo = isPurchase
      ? this.getLoyalAsParty()
      : this.extractCustomerInfo(shipment);

    // Create invoice items from shipment
    const items = this.createInvoiceItems(shipment);

    // Calculate totals
    const subtotal = items.reduce((sum, item) => sum + item.total_price, 0);
    const totalAmount = subtotal; // Add tax/discount logic if needed

    // Build invoice
    const invoice: Invoice = {
      id: crypto.randomUUID(),
      invoice_number: this.generatePreviewInvoiceNumber(type),
      invoice_date: new Date().toISOString().split('T')[0],
      type,
      language,
      
      seller,
      buyer,
      items,
      
      subtotal,
      total_amount: totalAmount,
      currency: 'USD',
      amount_in_words: this.numberToWords(totalAmount, 'en'),
      amount_in_words_ar: this.numberToWords(totalAmount, 'ar'),
      
      shipping: {
        vessel_name: (shipment as any).tanker_name || (shipment as any).vessel_name,
        bl_number: shipment.bl_no || undefined,
        container_count: shipment.container_count || undefined,
        port_of_loading: (shipment as any).pol_name,
        port_of_loading_ar: (shipment as any).pol_name,
        port_of_discharge: (shipment as any).pod_name,
        port_of_discharge_ar: (shipment as any).pod_name,
        eta: shipment.eta || undefined,
      },
      
      payment_terms: custom_payment_terms || this.getDefaultPaymentTerms(language),
      payment_terms_ar: custom_payment_terms || this.getDefaultPaymentTerms('ar'),
      bank_details: include_bank_details ? { ...LOYAL_BANK_DETAILS } : undefined,
      
      shipment_id: shipment.id,
      shipment_sn: shipment.sn,
      contract_id: shipment.contract_id || undefined,
      
      notes: custom_notes,
      notes_ar: custom_notes,
      
      company: { ...LOYAL_COMPANY_INFO },
      
      created_at: new Date().toISOString(),
    };

    return invoice;
  }

  /**
   * Generate and save invoice to database
   * Returns invoice with real invoice number from database sequence
   */
  async generateAndSaveInvoice(options: InvoiceGenerationOptions): Promise<Invoice | null> {
    // First generate the invoice data
    const invoice = await this.generateFromShipment(options);
    if (!invoice) {
      return null;
    }

    try {
      // Save to database and get real invoice number
      const savedInvoice = await accountingService.saveInvoice(invoice);
      
      // Return invoice with real invoice number
      return {
        ...invoice,
        id: savedInvoice.id,
        invoice_number: savedInvoice.invoice_number,
      };
    } catch (error) {
      console.error('[Invoice] Failed to save invoice:', error);
      throw error;
    }
  }

  /**
   * Get invoice by ID from database
   */
  async getInvoice(id: string): Promise<Invoice | null> {
    try {
      const savedInvoice = await accountingService.getInvoice(id);
      // Return the full invoice data stored in invoice_data field
      return savedInvoice.invoice_data as Invoice;
    } catch (error) {
      console.error('[Invoice] Failed to fetch invoice:', error);
      return null;
    }
  }

  /**
   * Update invoice status
   */
  async updateStatus(id: string, status: 'draft' | 'sent' | 'paid' | 'cancelled', cancelledReason?: string) {
    return accountingService.updateInvoiceStatus(id, status, cancelledReason);
  }

  /**
   * Extract supplier info from shipment
   */
  private extractSupplierInfo(shipment: Shipment): PartyInfo {
    // Try to get supplier from shipment or related data
    return {
      name: (shipment as any).supplier_name || 'Supplier',
      name_ar: (shipment as any).supplier_name || 'المورد',
      country: (shipment as any).supplier_country || '',
      address: (shipment as any).supplier_address || '',
    };
  }

  /**
   * Extract customer info from shipment
   */
  private extractCustomerInfo(shipment: Shipment): PartyInfo {
    // Try to get customer/buyer from shipment or final destination
    const finalDest = (shipment as any).final_destination;
    let customerName = 'Customer';
    
    if (finalDest) {
      const fd = typeof finalDest === 'string' ? JSON.parse(finalDest) : finalDest;
      customerName = fd.name || fd.owner || 'Customer';
    }

    return {
      name: customerName,
      name_ar: customerName,
      country: (shipment as any).buyer_country || '',
      address: (shipment as any).buyer_address || '',
    };
  }

  /**
   * Get Loyal company as a party
   */
  private getLoyalAsParty(): PartyInfo {
    return {
      name: LOYAL_COMPANY_INFO.name,
      name_ar: LOYAL_COMPANY_INFO.name_ar,
      address: LOYAL_COMPANY_INFO.address,
      address_ar: LOYAL_COMPANY_INFO.address_ar,
      phone: LOYAL_COMPANY_INFO.phone,
      email: LOYAL_COMPANY_INFO.email,
    };
  }

  /**
   * Create invoice items from shipment
   */
  private createInvoiceItems(shipment: Shipment): InvoiceItem[] {
    const weightTon = shipment.weight_ton ? parseFloat(String(shipment.weight_ton)) : 0;
    const weightKg = weightTon * 1000;
    const totalValue = shipment.total_value_usd ? parseFloat(String(shipment.total_value_usd)) : 0;
    const unitPrice = weightTon > 0 ? totalValue / weightTon : totalValue;

    return [{
      item_number: 1,
      product_name: shipment.product_text || 'Product',
      product_name_ar: shipment.product_text || 'المنتج',
      description: shipment.subject || '',
      description_ar: shipment.subject || '',
      origin: (shipment as any).origin_country || '',
      origin_ar: (shipment as any).origin_country || '',
      quantity: weightTon || 1,
      unit: 'MT',
      unit_ar: 'طن',
      weight_kg: weightKg,
      unit_price: unitPrice,
      total_price: totalValue,
      currency: 'USD',
    }];
  }

  /**
   * Get default payment terms
   */
  private getDefaultPaymentTerms(language: 'ar' | 'en' | 'bilingual'): string {
    if (language === 'ar') {
      return 'الدفع خلال 30 يوم من تاريخ الفاتورة';
    }
    return 'Payment within 30 days from invoice date';
  }

  /**
   * Convert number to words (simplified)
   */
  private numberToWords(amount: number, language: 'ar' | 'en'): string {
    const formatted = new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
    }).format(amount);

    if (language === 'ar') {
      return `${formatted} دولار أمريكي`;
    }
    return `${formatted} US Dollars`;
  }

  /**
   * Format date for display
   */
  formatDate(dateStr: string, language: InvoiceLanguage): string {
    const date = new Date(dateStr);
    const locale = language === 'ar' ? 'ar-SA' : 'en-US';
    return date.toLocaleDateString(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  }
}

export const invoiceService = new InvoiceService();
export default invoiceService;
